Небольшая инструкция:
Структура ответа имеет 4 подструткуры

data
  day_number --- номер дня в таблицах данных
  date --- строка, обозначающая календарную дату
  r_bid, r_ask, r_mid --- начальные данные
  u --- соответствующие данным сроки исполнения
  u_ann --- сроки выплат по (условному) аннуитету (по умолчанию 1:100)
  profile --- задает профиль выплат( по умолчанию ones(1,100))

method
  name(задачется внутри самой вызываемой функции) --- наименование метода (original, bounded, iterative, explicit, implicit, cauchy)
  замечание по методам. Методы explicit, implicit и cauchy дают почти неразличимые результаты, по сему удобнее использовать тот, что быстрее. В этом плане explicit --- самый тугой, лучше не трогать. Implicit --- всегда номально работает, но если хотите ускорить, то можно уменьшить изнутри метода параметр lambda внутри функции. Cauchy достаточно быстр на 20 данных и туго идет на 30. Исправляется при помощи лома, используя попраки значений точности у solvera. Iterative --- по классу уступает предыдущим, но тоже вполне себе работает. Bounded --- привел для справки. Это метод по жестким ограничениям. Для него значения чувствительности не может быть посчитано в принципе.
  DeltaSq --- подрузумевается квадратная матрица, отвечающая за ковариацию ошибки в ценах. На практике же удобно брать диагональную от
    спред/2 (разумеется необходимо раздвигать нулевые спреды)
    std (r_min/2) за 30 дней (нормировать можно не только на 2)
    спред/2 на инетравале 1:19.+раздвижение+ и 3/2 на 20:30
    то же, что и третий, только спред у первых двух сроков ограничить сверху
  alpha --- параметр модели ( по умолчанию 0.1) (забыл обговорить эту проблему)
  ufr --- по умолчанию log(1.042)
  r0 --- отправная точка для алгоритмов. Для original метода не имеет значения, поскольку этот метод использует только r_mid. Для всех остальных может быть выбрано как r_mean.
  sensefnk --- функция подсчета чувствительности метода.
  nsubiter --- внутренний параметр для итерационных методов, отвечает за точность. Лучше не трогать, пусть стоит по умолчанию 3.
  niter --- параметр, актуальный для iterative метода. Также нет смысла вникать

rule
  delta --- по сути означает ожидаемое значение невязки. (для метода Sense означает ожидаемое значение чувствительности, см.далее)
  name --- название критерия выбора парметра регуляризации. Может быть выбрано:
  	l2 --- норма невязки считается в соответствующем пространстве
	linf --- то же самое + в сочетании с delta = 1  и r0 = r_mean дает non-arbitrage(опять же есть трудности с раздвижением спреда)
  	R1 --- адаптивный метод выбора параметра. Для некоторого delta в среднем строит решение с невязкой, равно delta/2. При этом в зависимости от реального уровня кривости данных невязка может принять значения как 0.1, так и 5. Потому он адаптивный. Так что рекомендую дл него брать delta = 2. 
  	Sense --- метод фиксации чувствительности. В этом случае delta имеет смысл значения чувствительности. Нужное значение подбирается вручную. Рекомендую брать 0.003 для функции чувствительности с нормировкой на аннуитет, и 0.1 без нормировки.

result
  r --- новые цены
  xi --- в терминах SW это  вектор Qb.(нужна для построения кривой и не для чего более)
  dxi --- производная вектора xi по r0. (нужна лишь для построения чувстввительнотси аннуитета)
  grad --- вектор производная цены аннуитета к ценам инструментов
  sense --- значение чувствительности аннуитета(построенное по функции sensefnk)
  time --- время выполнения метода(бывает очень полезна для нахождения “клинических” случаев. Им характерно длительное время исполнения)
  annuity --- стоимость аннуитета, построенного по profile с выплатами в u_ann

Пустую структуру выпевывает функция getstruct(). Как ее заполнять можно посмотреть в скрипте main. Он по сути служит примером использования всех моих нагромаждений. 
Коротко о вспомогательных функциях
  [v,y,f] = getrates(arr_struct, T) --- выдает значения кривой. На вход можно подать массив структур и T, которое может быть просто точкой, интервалом или сеткой. На выходе 
  v --- временная сетка (если T --- это вектор, то v=T).
  y --- значение доходностей на сетке
  f --- плотность
  plotSW(arr_struct, T, color) --- отрисовка кривых.
  plotrates(struct) --- рисует бидаски и своп-кривую. Функиция кривая, надо править.

Вроде все. С параметром alpha история сложная. Пока считаем фиксироанным. 

Исправлена функция plotSW(arr_struct,'time', T,'color', color). Параметры ('time', T) или ('color', color) задаются опционально в любом порядке

Добавлено:
	функция h = SW(data,day,u,...) --- аналог старого main. Все параметры могут передаваться опционально. Их значения по умолчанию можно найти в getstruct().
		В качестве параметров НЕ ДОБАВЛЕН выбор матрицы нормировки(нужно править руками внутри функции путем раскомменчивания строки с spread = ***).
		Так для получения оригинального SW домтаточно запустить h0 = SW(data,10,1:20). К примеру для метода с критерием SENSE можно запустить 
		SW(data,day,1:30,'method','implicit','rule','Sense','delta',0.003). Именно так и используется функция для прогона на данных в 
	скрипте annuit.m, который 1) считатет кривые на всех данных и 2) строит графики по аануитетам(писал для себя)
	функция sensefnc.m выбирает метод подсчета меры чувствительности (S1,S2,S3) и нормирует или не нормирует эту величину на аннуитет ('y','n'). 
		Эти значения задаются через параметры функии SW, к примеру h0 = SW(data,10,1:20,'sensefnc','S2','denormsense','n');
	функция [sen,arrh,res] = fixSense( data,dayGrid,u,mres) решает обратную задачу для среднего уровня невязка mres на интервале dayGrid
		выбает уровень чувствительности sen, соответствующий массив результатов arrh и невязки res.
	скрипт  go по факту нужен для прогона figure('keypressfcn','clf;day=day+1;go').
	скритпт sense_test написан для отрисовки графиков по невязке, аннуитеты и пр. по уже посчитанным кривым arrh1. 
		таким образом для его работы нужно либо прогнать скрипт annuit, либо скопировать из уже готовых 
		arrh1 = impl_volat_30_S3_relev...
	
Добавлены посчитанные кривые:
	bounded.mat --- по факту не нужен. Решена задача с жесткими ограничениями. Пока про этот метод мы забыли до написания статьи.
	sampler.mat --- два массива для оригинального SW по 20 и 30 данным(orig_*0).
			два массива для регуляризации по методу implicit с нормировкой по спредам(раздвинутым) и критерием останова linf. То есть это безарбитраж
			один массив посчитанный на 30 днях по методу с фиксированной чувствительностью и с нормировкой до спредам, но за 20 тенором спред искусственно приравнен к 3bp.
			(оба предыдущих блока построенны давно, когда хранилась сама функция рассчета меры чувствительности, а не обозначения S1,S2...)
	sampler13_10 --- все три массива посчитаны при нормировке по месячной волатильности. Один по методу R1, и два по фикс. чувствительнсоти(0.003 и 0.004) 
	sampler14_10 --- дак же нормировка на фолатильность(кстати, посчитанную как mean(abs(std(PX_MID))) ), но уже уровень чувствителньости относительный 
			10% от чвств. исходного SW.
	